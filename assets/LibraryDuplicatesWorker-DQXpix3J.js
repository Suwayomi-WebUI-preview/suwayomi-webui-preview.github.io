var L=Object.defineProperty;var R=s=>{throw TypeError(s)};var _=(s,n,i)=>n in s?L(s,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):s[n]=i;var d=(s,n,i)=>_(s,typeof n!="symbol"?n+"":n,i),F=(s,n,i)=>n.has(s)||R("Cannot "+i);var g=(s,n,i)=>(F(s,n,"read from private field"),i?i.call(s):n.get(s)),K=(s,n,i)=>n.has(s)?R("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(s):n.set(s,i),f=(s,n,i,P)=>(F(s,n,"write to private field"),P?P.call(s,i):n.set(s,i),i);var q=(s,n,i,P)=>({set _(v){f(s,n,v,i)},get _(){return g(s,n,P)}});(function(){"use strict";var u,M,w,E,C;const s=r=>r.toLowerCase().trim(),n=r=>s(r).normalize("NFKC").replace(/[^\p{L}\p{N}]+/gu," ").trim(),i=r=>{const e=Object.groupBy(r,({title:t})=>n(t));return Object.fromEntries(Object.entries(e).filter(t=>{var o,h;return((h=(o=t[1])==null?void 0:o.length)!=null?h:0)>1}).map(([,t])=>[t[0].title,t]))};class P{constructor(e){d(this,"value");d(this,"next");this.value=e}}let v=(E=class{constructor(){K(this,u);K(this,M);K(this,w);this.clear()}enqueue(e){const t=new P(e);g(this,u)?(g(this,M).next=t,f(this,M,t)):(f(this,u,t),f(this,M,t)),q(this,w)._++}dequeue(){const e=g(this,u);if(e)return f(this,u,g(this,u).next),q(this,w)._--,e.value}peek(){if(g(this,u))return g(this,u).value}clear(){f(this,u,void 0),f(this,M,void 0),f(this,w,0)}get size(){return g(this,w)}*[Symbol.iterator](){let e=g(this,u);for(;e;)yield e.value,e=e.next}*drain(){for(;g(this,u);)yield this.dequeue()}},u=new WeakMap,M=new WeakMap,w=new WeakMap,E);function I(r){N(r);const e=new v;let t=0;const o=()=>{t<r&&e.size>0&&(t++,e.dequeue()())},h=()=>{t--,o()},l=async(a,p,c)=>{const y=(async()=>a(...c))();p(y);try{await y}catch(b){}h()},T=(a,p,c)=>{new Promise(y=>{e.enqueue(y)}).then(l.bind(void 0,a,p,c)),t<r&&o()},m=(a,...p)=>new Promise(c=>{T(a,c,p)});return Object.defineProperties(m,{activeCount:{get:()=>t},pendingCount:{get:()=>e.size},clearQueue:{value(){e.clear()}},concurrency:{get:()=>r,set(a){N(a),r=a,queueMicrotask(()=>{for(;t<r&&e.size>0;)o()})}},map:{async value(a,p){const c=a.map(y=>this(p,y));return Promise.all(c)}}}),m}function N(r){if(!((Number.isInteger(r)||r===Number.POSITIVE_INFINITY)&&r>0))throw new TypeError("Expected `concurrency` to be a number from 1 and up")}class k{constructor(){d(this,"orgResolve");d(this,"orgReject");d(this,"promise");this.promise=new Promise((e,t)=>{this.orgResolve=e,this.orgReject=t})}resolve(e){this.orgResolve(e)}reject(e){this.orgReject(e)}}class z{constructor(e){d(this,"queue");d(this,"counter",0);d(this,"pendingKeyToPriorityMap",new Map);d(this,"pendingKeyToFnMap",new Map);d(this,"pendingKeyToPromiseMap",new Map);this.queue=I(e)}clear(){this.pendingKeyToPromiseMap.forEach(e=>{e.reject(new Error("Queue::clear: called"))}),this.pendingKeyToPriorityMap.clear(),this.pendingKeyToFnMap.clear(),this.pendingKeyToPromiseMap.clear()}enqueue(e,t,o=1){this.counter=(this.counter+1)%Number.MAX_SAFE_INTEGER;const h="".concat(e,"_").concat(this.counter);this.pendingKeyToPriorityMap.set(h,o),this.pendingKeyToFnMap.set(h,t);const l=new k;return this.pendingKeyToPromiseMap.set(h,l),this.queue(()=>this.process()),{key:h,promise:l.promise}}isProcessing(e){return!this.pendingKeyToFnMap.has(e)}async process(){const{fn:e,promise:t}=this.getNextItemToProcess();try{const o=await e();t.resolve(o)}catch(o){t.reject(o)}}getNextItemToProcess(){const[e]=[...this.pendingKeyToPriorityMap.entries()].toSorted(([,h],[,l])=>l-h)[0],t=this.pendingKeyToFnMap.get(e),o=this.pendingKeyToPromiseMap.get(e);return this.pendingKeyToPriorityMap.delete(e),this.pendingKeyToFnMap.delete(e),this.pendingKeyToPromiseMap.delete(e),{key:e,fn:t,promise:o}}}const S=new z(((C=navigator.hardwareConcurrency)!=null?C:5)-1),j=200;self.onmessage=async r=>{const{mangas:e,checkAlternativeTitles:t}=r.data;if(!t){postMessage(i(e));return}const o=[];for(let m=0;m<e.length;m+=j)o.push(S.enqueue(m.toString(),()=>{const a=new k,p=new Worker(new URL(""+new URL("LibraryDuplicatesDescriptionWorker-D8fxrz0M.js",self.location.href).href,self.location.href),{type:"module"});return p.onmessage=c=>a.resolve(c.data),p.postMessage({mangas:e,mangasToCheck:e.slice(m,m+j)}),a.promise}).promise);const h=await Promise.all(o),l={},T={};h.forEach(m=>Object.entries(m).forEach(([a,p])=>{var b,x;const c=n(a);(b=T[c])!=null||(T[c]=a);const y=T[c];(x=l[y])!=null||(l[y]=p)})),postMessage(l)}})();
